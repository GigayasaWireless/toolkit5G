Channel Estimation and Equalization for PDCCH
=============================================
This module provides the channel estimator and equalizer for physical downlink control channel (PDCCH). The
implementation consists of 3 parts:

    1. Channel estimation
    2. Channel interpolation
    3. Symbol Equalization

The channel estimator supports **zero-forcing** (ZF) and **minimum mean square error** (MMSE) estimator. The channel
estimation is followed by interpolating the channel at time-frequency locations where information symbols are
transmitted. Currently, only nearest neighbour interpolator is supported but it will soon be extended to linear and 2D
spline interpolator as well. Finally once the channel is estimated at the symbol location, the equalization is performed
to offset the phase and scaling effect of the wireless channels.

.. note::
    Channel estimator supports zero-forcing (ZF) and minimum mean square error (MMSE) estimation methods.

.. note::
    Currently, only nearest neighbour interpolator is supported but it will soon be extended to linear and 2D spline interpolator as well.

.. note::
    For symbol Equalization, Least square method is used.


---------

**When Channel estimates are not available**


.. code:: ipython3

    AL            = 2
    interleaverType = "interleaved"
    L             = 2
    R             = 2
    nshift        = 204

    channelEst    = ChannelEstimationAndEqualizationPDCCH(AL, interleaverType, L, R, nshift)

    rxGrid        = np.random.randn(3, 4096) + 1j*np.random.randn(3, 4096) # SSB grid of size (4, 240)
    fdra          = np.array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0])
    duration      = 1
    slotNumber    = 1
    scramblingID  = 1
    Hp            = np.random.randn(3, 4096) + 1j*np.random.randn(3, 4096)
    equalized_Sym = channelEst(rxGrid, fdra,
                               duration, slotNumber, scramblingID, Hf = Hp)

    print(equalized_Sym.shape)


.. parsed-literal::

    (108,)


**When Channel estimates are available**


.. code:: ipython3

    AL            = 2
    interleaverType = "non-interleaved"
    L             = 2
    R             = 2
    nshift        = 204

    channelEst    = ChannelEstimationAndEqualizationPDCCH(AL, interleaverType, L, R, nshift)

    rxGrid        = np.random.randn(10, 3, 4096) + 1j*np.random.randn(10, 3, 4096) # SSB grid of size (4, 240)
    fdra          = np.array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0])
    duration      = 1
    slotNumber    = 1
    scramblingID  = 1
    Hp            = None
    equalized_Sym = channelEst(rxGrid, fdra,
                               duration, slotNumber, scramblingID, Hf = Hp)

    print(equalized_Sym.shape)


.. parsed-literal::

    (10,216)

---------

.. tip::
    The values for the above scripts are generated using PDCCH test bench. You can access it from the tutorials.

**API Documentation**


The details about the input-output interface of the ReceiveCombining modules is provided below.

.. autoclass:: toolkit5G.ReceiverAlgorithms.ChannelEstimationAndEqualizationPDCCH
    :members:
    :exclude-members: call, build

