{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "080069f0",
   "metadata": {},
   "source": [
    "# Wireless Channel Dataset Generation for Training the AI based Models\n",
    "\n",
    "Wireless channel dataset generation and preprocessing involve the creation and preparation of datasets containing information about the wireless communication channel. Here's an overview of the process:\n",
    "\n",
    "1. **Dataset Generation**:\n",
    "\n",
    "    - **Simulation** (``We are using this``): One common approach is to use channel modeling and simulation software to generate synthetic datasets. This involves modeling various channel characteristics such as path loss, shadowing, multipath propagation, and fading effects.\n",
    "    \n",
    "    - **Measurement**: Real-world measurements can be collected using specialized hardware and equipment deployed in different environments. These measurements capture the characteristics of the wireless channel under various conditions and scenarios.\n",
    "\n",
    "2. **Data Collection**:\n",
    "\n",
    "    - In simulation-based approaches, data is generated by simulating the propagation of electromagnetic waves through the environment and computing channel parameters such as signal strength, delay spread, and Doppler shift.\n",
    "    - In measurement-based approaches, data is collected by measuring the received signal strength and other relevant parameters at multiple locations in the environment over time.\n",
    "\n",
    "3. **Data Preprocessing**:\n",
    "\n",
    "    - **Cleaning**: The collected data may contain errors, outliers, or missing values that need to be identified and corrected. Cleaning involves removing or correcting these inconsistencies to ensure the quality of the dataset.\n",
    "    - **Normalization**: Data normalization involves scaling the values of features to a standard range to ensure uniformity and comparability across different features.\n",
    "    - **Feature Extraction**: Relevant features such as signal strength, delay spread, angle of arrival, and Doppler shift are extracted from the raw data. Feature extraction may involve signal processing techniques such as Fourier transforms, wavelet analysis, or machine learning algorithms.\n",
    "    - **Dimensionality Reduction**: In some cases, datasets may contain a large number of features, leading to computational complexity and overfitting. Dimensionality reduction techniques such as Principal Component Analysis (PCA) or feature selection methods are applied to reduce the number of features while preserving the most relevant information.\n",
    "\n",
    "\n",
    "Wireless channel dataset generation and preprocessing are crucial steps in the development of machine learning models, algorithms, and systems for wireless communication. A well-prepared dataset ensures the accuracy, reliability, and generalizability of the models and systems built upon it.\n",
    "\n",
    "\n",
    "## Import Python Libraries\n",
    "\n",
    "### Import Basic Python LIbraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7eb02cb4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# %matplotlib widgets\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib as mpl\n",
    "\n",
    "import os\n",
    "os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n",
    "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' \n",
    "\n",
    "import numpy as np\n",
    "\n",
    "# from IPython.display import display, HTML\n",
    "# display(HTML(\"<style>.container { width:80% !important; }</style>\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37306fc7",
   "metadata": {},
   "source": [
    "### Import 5G Toolkit Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "9934198e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from csiNet import CSINet\n",
    "\n",
    "import sys\n",
    "sys.path.append(\"../../\")\n",
    "\n",
    "from toolkit5G.PhysicalChannels.PDSCH import ComputeTransportBlockSize\n",
    "from toolkit5G.PhysicalChannels       import PDSCHLowerPhy, PDSCHUpperPhy, PDSCHDecoderLowerPhy, PDSCHDecoderUpperPhy\n",
    "from toolkit5G.ChannelModels          import AntennaArrays, SimulationLayout, ParameterGenerator, ChannelGenerator\n",
    "from toolkit5G.Configurations         import PDSCHLowerPhyConfiguration, PDSCHUpperPhyConfiguration\n",
    "from toolkit5G.ChannelProcessing      import AddNoise, ApplyChannel\n",
    "from toolkit5G.SymbolMapping          import Mapper, Demapper"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6a234109",
   "metadata": {},
   "source": [
    "## Simulation Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "c42e12d3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "************ Simulation Parameters *************\n",
      "\n",
      "     numBatches: 10000\n",
      "          numRB: 85\n",
      "       fft Size: 1024\n",
      "         numBSs: 1\n",
      "         numUEs: 10000\n",
      "            scs: 30000\n",
      "     slotNumber: 9\n",
      "        terrain: CDL-A\n",
      "Tx Ant Struture: [ 1  1 32  1  1]\n",
      "Rx Ant Struture: [1 1 1 1 1]\n",
      "\n",
      "********************************************\n"
     ]
    }
   ],
   "source": [
    "# Carrier Frequency\n",
    "carrierFrequency = 3.6*10**9 \n",
    "delaySpread   = 100*(10**-9)\n",
    "numBatches    = 10000       # Number of batches considered for simulation\n",
    "scs           = 30*10**3  # Subcarrier Spacing for simulation\n",
    "numBSs        = 1 # Number of BSs considered for simulation\n",
    "# Number of UEs considered for simulation\n",
    "numUEs        = numBatches # For now we are assuming that the numbatches are captured via numUEs\n",
    "numRB         = 85 # Number of Resource mapping considered for simulation | # 1 RB = 12 subcarrier\n",
    "slotNumber    = int(np.random.randint(0,2**(scs/15000)*10)) # Index of the slot considered for simulation\n",
    "terrain       = \"CDL-A\" # Terrain\n",
    "txAntStruture = np.array([1,1,32,1,1]) # Tx Antenna Structure\n",
    "rxAntStruture = np.array([1,1,1,1,1]) # Tx Antenna Structure\n",
    "Nfft          = 1024 # FFTSize\n",
    "\n",
    "print(\"************ Simulation Parameters *************\")\n",
    "print()\n",
    "print(\"     numBatches: \"+str(numBatches))\n",
    "print(\"          numRB: \"+str(numRB))\n",
    "print(\"       fft Size: \"+str(Nfft))\n",
    "print(\"         numBSs: \"+str(numBSs))\n",
    "print(\"         numUEs: \"+str(numUEs))\n",
    "print(\"            scs: \"+str(scs))\n",
    "print(\"     slotNumber: \"+str(slotNumber))\n",
    "print(\"        terrain: \"+str(terrain))\n",
    "print(\"Tx Ant Struture: \"+str(txAntStruture))\n",
    "print(\"Rx Ant Struture: \"+str(rxAntStruture))\n",
    "print()\n",
    "print(\"********************************************\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4116f8ad",
   "metadata": {},
   "source": [
    "## Set Channel Parameters and Generate Common Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "8e7ba9fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Antenna Array at UE side\n",
    "# assuming antenna element type to be \"OMNI\"\n",
    "# with 2 panel and 2 single polarized antenna element per panel.\n",
    "ueAntArray = AntennaArrays(antennaType = \"OMNI\",  centerFrequency = carrierFrequency, \n",
    "                           arrayStructure  = rxAntStruture)\n",
    "ueAntArray()\n",
    "\n",
    "# # Radiation Pattern of Rx antenna element \n",
    "# ueAntArray.displayAntennaRadiationPattern()\n",
    "\n",
    "\n",
    "# Antenna Array at BS side\n",
    "# assuming antenna element type to be \"3GPP_38.901\", a parabolic antenna \n",
    "# with 4 panel and 4 single polarized antenna element per panel.\n",
    "bsAntArray = AntennaArrays(antennaType = \"3GPP_38.901\", centerFrequency = carrierFrequency,\n",
    "                           arrayStructure  = txAntStruture)\n",
    "bsAntArray()\n",
    "    \n",
    "# # Radiation Pattern of Tx antenna element \n",
    "# bsAntArray[0].displayAntennaRadiationPattern()\n",
    "\n",
    "# Layout Parameters\n",
    "isd                  = 200         # inter site distance\n",
    "minDist              = 10          # min distance between each UE and BS \n",
    "ueHt                 = 1.5         # UE height\n",
    "bsHt                 = 25          # BS height\n",
    "bslayoutType         = \"Hexagonal\" # BS layout type\n",
    "ueDropType           = \"Hexagonal\" # UE drop type\n",
    "htDist               = \"equal\"     # UE height distribution\n",
    "ueDist               = \"equal\"     # UE Distribution per site\n",
    "nSectorsPerSite      = 1           # number of sectors per site\n",
    "maxNumFloors         = 1           # Max number of floors in an indoor object\n",
    "minNumFloors         = 1           # Min number of floors in an indoor object\n",
    "heightOfRoom         = 3           # height of room or ceiling in meters\n",
    "indoorUEfract        = 0.5         # Fraction of UEs located indoor\n",
    "lengthOfIndoorObject = 3           # length of indoor object typically having rectangular geometry \n",
    "widthOfIndoorObject  = 3           # width of indoor object\n",
    "# forceLOS             = True       # boolen flag if true forces every link to be in LOS state\n",
    "forceLOS             = False       # boolen flag if true forces every link to be in LOS state\n",
    "\n",
    "Nt        = bsAntArray.numAntennas # Number of BS Antennas\n",
    "Nr        = ueAntArray.numAntennas\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "45c69959",
   "metadata": {},
   "source": [
    "## Generate the Wireless Channels Databases and Preprocess it before storage.\n",
    "\n",
    "1. Generate OFDM Wireless Channels.\n",
    "2. Preprocess the OFDM Channel\n",
    "3. Store the preprocessed wireless channels\n",
    "\n",
    "``Important``: Make sure you have **Databases** directory/folder where datasets will be stored."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f421b76",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             Number of BSs: 1\n",
      "          Shape of Channel: (10000, 32, 1024)\n",
      "*****************************************************\n",
      "\n",
      "             Number of BSs: 1\n",
      "          Shape of Channel: (10000, 32, 1024)\n",
      "*****************************************************\n",
      "\n",
      "             Number of BSs: 1\n",
      "          Shape of Channel: (10000, 32, 1024)\n",
      "*****************************************************\n",
      "\n",
      "             Number of BSs: 1\n",
      "          Shape of Channel: (10000, 32, 1024)\n",
      "*****************************************************\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MonteCarloIterations = 10\n",
    "\n",
    "numTaps       = 32\n",
    "codewordSize  = 512\n",
    "\n",
    "for mci in range(4,MonteCarloIterations):\n",
    "    # simulation layout object                                 \n",
    "    simLayoutObj = SimulationLayout(numOfBS = numBSs,\n",
    "                                    numOfUE = numUEs,\n",
    "                                    heightOfBS = bsHt,\n",
    "                                    heightOfUE = ueHt, \n",
    "                                    ISD = isd,\n",
    "                                    layoutType = bslayoutType,\n",
    "                                    ueDropMethod = ueDropType, \n",
    "                                    UEdistibution = ueDist,\n",
    "                                    UEheightDistribution = htDist,\n",
    "                                    numOfSectorsPerSite = nSectorsPerSite,\n",
    "                                    ueRoute = None)\n",
    "\n",
    "    simLayoutObj(terrain = terrain, \n",
    "                 carrierFreq = carrierFrequency, \n",
    "                 ueAntennaArray = ueAntArray,\n",
    "                 bsAntennaArray = bsAntArray,\n",
    "                 indoorUEfraction = indoorUEfract,\n",
    "                 lengthOfIndoorObject = lengthOfIndoorObject,\n",
    "                 widthOfIndoorObject = widthOfIndoorObject,\n",
    "                 forceLOS = forceLOS)\n",
    "\n",
    "    # displaying the topology of simulation layout\n",
    "#     fig, ax = simLayoutObj.display2DTopology()\n",
    "\n",
    "    paramGen = simLayoutObj.getParameterGenerator(delaySpread = delaySpread)\n",
    "\n",
    "    # paramGen.displayClusters((0,0,0), rayIndex = 0)\n",
    "    channel  = paramGen.getChannel()\n",
    "    \n",
    "    # Generate OFDM Channel\n",
    "    Hf       = channel.ofdm(scs, Nfft, normalizeChannel = True)[0,0,0,...,0,:].transpose(0,2,1)\n",
    "\n",
    "    # Preprocess the Frequency Domain channel\n",
    "    csinet   = CSINet()\n",
    "    model    = csinet(Nt, numTaps, codewordSize)\n",
    "    Hprep    = csinet.preprocess(Hf)\n",
    "    \n",
    "    np.savez(\"Databases/PreprocessedChannel-dB-\"+str(mci)+\".npz\",\n",
    "             Hprep = Hprep, Nfft  = Nfft, Nt = Nt, codewordSize  = codewordSize, numTaps = numTaps,\n",
    "             carrierFrequency = carrierFrequency, terrain = terrain, delaySpread = delaySpread, \n",
    "             isd = isd, txAntStruture = txAntStruture, rxAntStruture = rxAntStruture)\n",
    "\n",
    "    print(\"             Number of BSs: \"+str(numBSs))\n",
    "    print(\"          Shape of Channel: \"+str(Hf.shape))\n",
    "    print(\"*****************************************************\")\n",
    "    print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f4dcdbc",
   "metadata": {},
   "source": [
    "## Aggregate all the Datasets into a single Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97ab88bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "filename = \"Databases/PreprocessedChannel-dB-\"+str(0)+\".npz\"\n",
    "db = np.load(filename)\n",
    "Hp = db[\"Hprep\"]\n",
    "for mci in range(1,10):\n",
    "    filename = \"Databases/PreprocessedChannel-dB-\"+str(mci)+\".npz\"\n",
    "    db = np.load(filename)\n",
    "    Hp = np.concatenate([Hp, db[\"Hprep\"]], axis=0)\n",
    "    \n",
    "np.savez(\"Databases/PreprocessedChannel-dB.npz\", Hp = Hp, Nfft  = 1024, Nt = 32)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "24ee3125",
   "metadata": {},
   "source": [
    "## Display Sparsity of Wireless Channels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd99db8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "numChannels = 10\n",
    "numBatches  = Hp.shape[0]\n",
    "idx         = np.random.choice(np.arange(numBatches), size=numChannels, replace = False)\n",
    "\n",
    "fig, ax = plt.subplots(2,10, figsize = (17.5, 5))\n",
    "\n",
    "print(idx)\n",
    "for n in range(numChannels):\n",
    "    ax[0,n].imshow(np.abs(Hp[idx[n],0])**2 + np.abs(Hp[idx[n],1])**2, cmap = \"Greys\", aspect = \"auto\")\n",
    "#     ax[1,n].imshow(np.abs( Hrec[idx[n],0])**2 + np.abs( Hrec[idx[n],1])**2, cmap = \"Greys\", aspect = \"auto\")\n",
    "    \n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
